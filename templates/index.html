<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Player</title>
    <link rel="stylesheet" href="/static/index.css">
    <script>
            let albumData = {}; // ì•¨ë²” ë°ì´í„°ë¥¼ ì €ì¥
            let searchIndex = []; // ê²€ìƒ‰ ì¸ë±ìŠ¤
            let albumKeys = []; // ì•¨ë²” ìˆœì„œë¥¼ ì €ì¥
            let currentAlbumIndex = 0; // í˜„ì¬ ì•¨ë²” ì¸ë±ìŠ¤
            let currentTrackIndex = 0; // í˜„ì¬ íŠ¸ë™ ì¸ë±ìŠ¤
            let audioDuration = 0; // í˜„ì¬ íŠ¸ë™ ê¸¸ì´ ì €ì¥

        // ì „ì—­ `trackTimeUpdate` í•¨ìˆ˜ ì •ì˜
        function trackTimeUpdate() {
            const audioElement = document.getElementById('audio-player');
            if (audioElement.currentTime >= audioDuration) {
                console.log("íŠ¸ë™ ì¢…ë£Œ ê°ì§€ -> ë‹¤ìŒ ê³¡ìœ¼ë¡œ ì´ë™");
                nextTrack();
            }
            }
        // JSON ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
        async function fetchAlbumData() {
            const response = await fetch('/albums_list');
            albumData = await response.json();
            albumKeys = Object.keys(albumData);
            createSearchIndex(albumData); // ê²€ìƒ‰ ì¸ë±ìŠ¤ ìƒì„±
            renderSidebar(); // ì´ˆê¸° ìƒíƒœë¡œ ì „ì²´ ë°ì´í„° í‘œì‹œ
            updateTrackInfo();
        }


        // ê²€ìƒ‰ ì¸ë±ìŠ¤ ìƒì„±
        function createSearchIndex(data) {
            searchIndex = [];
            Object.keys(data).forEach(albumKey => {
                data[albumKey].forEach(track => {
                    searchIndex.push({
                        album: albumKey.toLowerCase(),
                        track: track.name.toLowerCase(),
                        path: track.path
                    });
                });
            });
        }

        // ê²€ìƒ‰ ê¸°ëŠ¥
        function searchTracks() {
            const query = document.getElementById('search-bar').value.toLowerCase();
            const filteredTracks = searchIndex.filter(item =>
                item.album.includes(query) || item.track.includes(query)
            );

            const filteredData = {};
            filteredTracks.forEach(item => {
                if (!filteredData[item.album]) filteredData[item.album] = [];
                filteredData[item.album].push({ name: item.track, path: item.path });
            });

            renderSidebar(filteredData);
        }

        // ìŠ¬ë¼ì´ë”ë°”ì— ì•¨ë²”ê³¼ íŠ¸ë™ í‘œì‹œ
        function renderSidebar(filteredData = null) {
            const sidebar = document.querySelector('.sidebar-content');
            sidebar.innerHTML = ''; // ê¸°ì¡´ ë‚´ìš© ì´ˆê¸°í™”
            const data = filteredData || albumData;

            Object.keys(data).forEach((albumKey) => {
                // ì•¨ë²” í—¤ë”
                const albumHeader = document.createElement('div');
                albumHeader.textContent = albumKey;
                albumHeader.className = 'sidebar-album';
                sidebar.appendChild(albumHeader);

                // íŠ¸ë™ ë¦¬ìŠ¤íŠ¸
                data[albumKey].forEach((track) => {
                    const trackDiv = document.createElement('div');
                    trackDiv.textContent = track.name;
                    trackDiv.className = 'sidebar-track';
                    trackDiv.onclick = () => {
                        playTrackByPath(track.path); // ê²½ë¡œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê³¡ ì¬ìƒ
                    };
                    sidebar.appendChild(trackDiv);
                });
            });
        }

        // ê²½ë¡œ ê¸°ë°˜ìœ¼ë¡œ ê³¡ ì¬ìƒ
        function playTrackByPath(path) {
            const foundTrack = findTrackByPath(path);
            if (foundTrack) {
                const { albumKey, trackIndex } = foundTrack;
                currentAlbumIndex = albumKeys.indexOf(albumKey);
                currentTrackIndex = trackIndex;
                updateTrackInfo();
            } else {
                console.error(`Track with path "${path}" not found in albumData.`);
            }
        }

        // ê²½ë¡œ ê¸°ë°˜ìœ¼ë¡œ íŠ¸ë™ ì°¾ê¸°
        function findTrackByPath(path) {
            for (const albumKey of albumKeys) {
                const trackIndex = albumData[albumKey].findIndex((track) => track.path === path);
                if (trackIndex !== -1) {
                    return { albumKey, trackIndex };
                }
            }
            return null;
        }

        // ì˜¤ë””ì˜¤ ê¸¸ì´ ê°€ì ¸ì˜¤ê¸° (ìºì‹± ì œê±°)
        async function fetchAudioDuration(path) {
            try {
                const response = await fetch(`/audio/duration/${encodeURIComponent(path.split('\\').pop())}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch audio duration');
                }
                const { duration } = await response.json();
                return duration;
            } catch (error) {
                console.error(error);
                return 0;
            }
        }


        async function updateTrackInfo() {
            const audioElement = document.getElementById('audio-player');
            const titleElement = document.getElementById('track-title');
            const coverElement = document.getElementById('album-cover');

            const currentAlbum = albumKeys[currentAlbumIndex];
            const currentTrack = albumData[currentAlbum][currentTrackIndex];
            const encodedFilename = encodeURIComponent(currentTrack.path.split('\\').pop());

            // ê¸°ì¡´ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
            audioElement.removeEventListener("timeupdate", trackTimeUpdate);
            audioElement.removeEventListener("ended", nextTrack);

            // UI ì—…ë°ì´íŠ¸
            titleElement.textContent = `${currentTrack.name}`;
            audioElement.src = `/audio/${encodedFilename}`;
            coverElement.src = `/cover/${encodedFilename}`;
            coverElement.onerror = () => {
                coverElement.src = '/public/none';
                coverElement.onerror = null;
            };

            try {
                // ìƒˆë¡œìš´ ê³¡ì˜ ê¸¸ì´ë¥¼ ê°€ì ¸ì˜¤ê¸°
                audioDuration = await fetchAudioDuration(currentTrack.path);
                console.log("ğŸ”¹ ìƒˆë¡œìš´ íŠ¸ë™ ê¸¸ì´ (ì´ˆ):", audioDuration);

                // ìƒˆ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
                audioElement.addEventListener("timeupdate", trackTimeUpdate);
                audioElement.addEventListener("ended", nextTrack);

                // ì˜¤ë””ì˜¤ ë¡œë“œ ë° ì¬ìƒ
                audioElement.load();
                audioElement.addEventListener('canplay', () => {
                    audioElement.play().catch(error => {
                        console.error("Playback failed:", error);
                    });
                }, { once: true });
            } catch (error) {
                console.error("ì˜¤ë¥˜ ë°œìƒ:", error);
            }
        }

// ì˜¤ë””ì˜¤ ê¸¸ì´ ê°€ì ¸ì˜¤ê¸° (ì„œë²„ ì˜¤ë¥˜ ë°œìƒ ì‹œ ê¸°ë³¸ê°’ ì œê³µ)
        async function fetchAudioDuration(path) {
            try {
                const response = await fetch(`/audio/duration/${encodeURIComponent(path.split('\\').pop())}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch audio duration');
                }
                const { duration } = await response.json();
                return Math.floor(duration-1);
            } catch (error) {
                console.error("fetchAudioDuration ì˜¤ë¥˜:", error);
                return 10;  // ì„œë²„ ì˜¤ë¥˜ ë°œìƒ ì‹œ ê¸°ë³¸ê°’ (10ì´ˆ) ì œê³µ
            }
        }




        // ë‹¤ìŒ íŠ¸ë™ (3ì´ˆ ë‚´ ì¬ìƒ ì‹¤íŒ¨ ì‹œ ìë™ ì´ë™)
        function nextTrack() {
            const audioElement = document.getElementById("audio-player");
            const currentAlbum = albumKeys[currentAlbumIndex];

            if (currentTrackIndex + 1 < albumData[currentAlbum].length) {
                currentTrackIndex++;
            } else if (currentAlbumIndex + 1 < albumKeys.length) {
                currentAlbumIndex++;
                currentTrackIndex = 0;
            } else {
                currentAlbumIndex = 0;
                currentTrackIndex = 0;
            }

            updateTrackInfo();

            // 3ì´ˆ ë‚´ ì¬ìƒë˜ì§€ ì•Šìœ¼ë©´ ê°•ì œ íŠ¸ë™ ë³€ê²½
            let timeout = setTimeout(() => {
                if (audioElement.paused) {
                    console.log("3ì´ˆ ë™ì•ˆ ì¬ìƒë˜ì§€ ì•ŠìŒ â†’ ë‹¤ìŒ íŠ¸ë™ìœ¼ë¡œ ì´ë™");
                    nextTrack();
                }
            }, 3000); // 3ì´ˆ í›„ ì²´í¬

            //  ì¬ìƒ ì‹œì‘ ê°ì§€ ì‹œ íƒ€ì„ì•„ì›ƒ ì œê±°
            audioElement.addEventListener("playing", () => {
                console.log("ì •ìƒ ì¬ìƒë¨ â†’ íŠ¸ë™ ë³€ê²½ ì·¨ì†Œ");
                clearTimeout(timeout);
            }, { once: true }); // í•œ ë²ˆë§Œ ì‹¤í–‰ë˜ë„ë¡ ì„¤ì •
        }

        // ì´ì „ íŠ¸ë™
        function previousTrack() {
            if (currentTrackIndex > 0) {
                currentTrackIndex--;
            } else if (currentAlbumIndex > 0) {
                currentAlbumIndex--;
                const prevAlbum = albumKeys[currentAlbumIndex];
                currentTrackIndex = albumData[prevAlbum].length - 1;
            } else {
                currentAlbumIndex = albumKeys.length - 1;
                const lastAlbum = albumKeys[currentAlbumIndex];
                currentTrackIndex = albumData[lastAlbum].length - 1;
            }
            updateTrackInfo();
        }
        window.onload = function () {
            fetchAlbumData(); // ì•¨ë²” ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
            document.getElementById('search-bar').addEventListener('input', searchTracks);
        };

        function playRandomTrack() {
            if (albumKeys.length === 0 || Object.keys(albumData).length === 0) {
                console.error("Album data is not loaded yet.");
                return;
            }
            const randomAlbumIndex = Math.floor(Math.random() * albumKeys.length);
            const randomTrackIndex = Math.floor(Math.random() * albumData[albumKeys[randomAlbumIndex]].length);
            currentAlbumIndex = randomAlbumIndex;
            currentTrackIndex = randomTrackIndex;
            updateTrackInfo();
        }
    </script>
</head>

<body>
    <div class="title"><h1>Audio Player</h1></div>
    <div class="main">
        <div class="content">
            <div class="player">
                <input type="text" id="search-bar" placeholder="Search for albums or tracks...">
                <h3 id="track-title"></h3> <!-- ê³¡ëª… í‘œì‹œ -->
                <img id="album-cover" src="/public/none" alt="Album Cover" width="300" height="300" />
                <audio id="audio-player" controls>
                    <source id="audio-source" src="" type="audio/flac">
                    Your browser does not support the audio element.
                </audio>
                <div class="buttons">
                    <button onclick="previousTrack()">Previous Track</button>
                    <button onclick="nextTrack()">Next Track</button>
                </div>
            </div>
            <div class="sidebar">
                <div class="sidebar-content">
                </div>
            </div>
            <div class ="random-play">
                <button onclick="playRandomTrack()">Random Play</button>
        </div>
    </div>
</body>

</html>
