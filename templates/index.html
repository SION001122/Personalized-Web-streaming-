<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Audio Player</title>
  <link rel="stylesheet" href="/static/index.css">
  <style>
    .sidebar {
      width: 300px;
      height: 600px;
      overflow-y: auto;
      border: 1px solid #ccc;
      -webkit-overflow-scrolling: touch;
    }
    .sidebar-track {
      padding: 4px 10px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
      background: #fff;
      white-space: normal;
      overflow-wrap: break-word;
      text-overflow: clip;
    }
    .sidebar-album {
      font-weight: bold;
      background: #f0f0f0;
      padding: 4px 10px;
      white-space: normal;
      overflow-wrap: break-word;
      text-overflow: clip;
    }
    #audio-player {
      margin-top: 10px;
      width: 250px;
      height: 40px;
    }
  </style>

  <!-- MiniSearch -->
  <script src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js"></script>
  <!-- Clusterize.js -->
  <script src="https://unpkg.com/clusterize.js/clusterize.min.js"></script>

<script>
    const basename = (p) => p.split(/[/\\]/).pop();
    const stripExt = (name) => name.replace(/\.[^.]+$/, "");
    const escapeHtml = (s) =>
      String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));

    let albumData = {};
    let albumKeys = [];
    let currentAlbumIndex = 0;
    let currentTrackIndex = 0;

    let flatTrackList = [];
    let loadedAlbumCount = 0;
    const ALBUM_BATCH_SIZE = 10;

    let miniSearch;
    let clusterize;

    async function fetchAlbumData() {
    const response = await fetch('/albums_list');
    albumData = await response.json();
    albumKeys = Object.keys(albumData);
    createSearchIndex(albumData);

    // 한방에 전부 넣기
    flatTrackList = [];
    albumKeys.forEach(albumKey => {
        flatTrackList.push({ type: "album", name: albumKey });
        albumData[albumKey].forEach(track => {
        flatTrackList.push({ type: "track", album: albumKey, track });
        });
    });

    renderSidebar(true);
    updateTrackInfo();
    }


    function loadMoreAlbums() {
      const nextAlbums = albumKeys.slice(loadedAlbumCount, loadedAlbumCount + ALBUM_BATCH_SIZE);
      nextAlbums.forEach(albumKey => {
        flatTrackList.push({ type: "album", name: albumKey });
        albumData[albumKey].forEach(track => {
          flatTrackList.push({ type: "track", album: albumKey, track });
        });
      });
      loadedAlbumCount += nextAlbums.length;
    }

    function createSearchIndex(data) {
      let docs = [];
      Object.keys(data).forEach(albumKey => {
        data[albumKey].forEach(track => {
          docs.push({
            id: `${albumKey}_${track.path}`,
            album: albumKey,
            track: track.name,
            path: track.path
          });
        });
      });

      miniSearch = new MiniSearch({
        fields: ['album', 'track'],
        storeFields: ['album', 'track', 'path'],
      });

      miniSearch.addAll(docs);
    }

    function searchTracks(query) {
      if (!miniSearch) return;

      if (!query) {
        flatTrackList = [];
        albumKeys.forEach(albumKey => {
          flatTrackList.push({ type: "album", name: albumKey });
          albumData[albumKey].forEach(track => {
            flatTrackList.push({ type: "track", album: albumKey, track });
          });
        });
        renderSidebar(true);
        return;
      }

      const results = miniSearch.search(query, { fuzzy: 0.2, prefix: true });

      const filteredData = {};
      results.forEach(item => {
        if (!filteredData[item.album]) filteredData[item.album] = [];
        filteredData[item.album].push({ name: item.track, path: item.path });
      });

      flatTrackList = [];
      Object.keys(filteredData).forEach(albumKey => {
        flatTrackList.push({ type: "album", name: albumKey });
        filteredData[albumKey].forEach(track => {
          flatTrackList.push({ type: "track", album: albumKey, track });
        });
      });

      renderSidebar(true);
    }

    function renderSidebar(reset = false) {
      const rows = flatTrackList.map(item => {
        if (item.type === "album") {
          return `<div class="sidebar-album">${escapeHtml(item.name)}</div>`;
        } else {
          // onclick 대신 data-path + 이벤트 위임 사용
          return `<div class="sidebar-track" data-path="${escapeHtml(item.track.path)}">${escapeHtml(item.track.name)}</div>`;
        }
      });

      if (!clusterize) {
        clusterize = new Clusterize({
          rows,
          scrollId: 'scrollArea',
          contentId: 'contentArea',
          rows_in_block: 30,
          blocks_in_cluster: 2
        });
      } else {
        clusterize.update(rows);
      }
    }

    function playTrackByPath(path) {
      const foundTrack = findTrackByPath(path);
      if (foundTrack) {
        const { albumKey, trackIndex } = foundTrack;
        currentAlbumIndex = albumKeys.indexOf(albumKey);
        currentTrackIndex = trackIndex;
        updateTrackInfo();
      }
    }

    function findTrackByPath(path) {
      for (const albumKey of albumKeys) {
        const trackIndex = albumData[albumKey].findIndex((track) => track.path === path);
        if (trackIndex !== -1) {
          return { albumKey, trackIndex };
        }
      }
      return null;
    }

    async function updateTrackInfo() {
      const audioElement = document.getElementById('audio-player');
      const titleElement = document.getElementById('track-title');
      const coverElement = document.getElementById('album-cover');

      const currentAlbum = albumKeys[currentAlbumIndex];
      const currentTrack = albumData[currentAlbum][currentTrackIndex];

      const fileWithExt = basename(currentTrack.path);
      const encoded = encodeURIComponent(fileWithExt);
      const displayName = stripExt(fileWithExt);

      titleElement.textContent = displayName;
      audioElement.src = `/audio/${encoded}`;
      coverElement.src = `/cover/${encoded}`;
      coverElement.onerror = () => {
        if (!coverElement.dataset.fallback) {
          coverElement.src = '/public/none';
          coverElement.dataset.fallback = "true";
        }
      };

      try {
        audioElement.load();
        justLoaded = true;
        setTimeout(() => { justLoaded = false; }, 2000);

        fetch(`/audio/duration/${encoded}`)
          .then(res => res.json())
          .then(data => {
            if (data.duration) {
              audioElement.dataset.duration = data.duration;
              console.log(`서버 제공 duration: ${data.duration.toFixed(2)}초`);
            }
          })
          .catch(() => {});

        audioElement.play().catch(() => {});
      } catch (err) {}
    }

    function nextTrack() {
      const currentAlbum = albumKeys[currentAlbumIndex];
      if (currentTrackIndex + 1 < albumData[currentAlbum].length) {
        currentTrackIndex++;
      } else if (currentAlbumIndex + 1 < albumKeys.length) {
        currentAlbumIndex++;
        currentTrackIndex = 0;
      } else {
        currentAlbumIndex = 0;
        currentTrackIndex = 0;
      }
      updateTrackInfo();
    }

    function previousTrack() {
      if (currentTrackIndex > 0) {
        currentTrackIndex--;
      } else if (currentAlbumIndex > 0) {
        currentAlbumIndex--;
        const prevAlbum = albumKeys[currentAlbumIndex];
        currentTrackIndex = albumData[prevAlbum].length - 1;
      } else {
        currentAlbumIndex = albumKeys.length - 1;
        const lastAlbum = albumKeys[currentAlbumIndex];
        currentTrackIndex = albumData[lastAlbum].length - 1;
      }
      updateTrackInfo();
    }

    function playRandomTrack() {
      if (albumKeys.length === 0) return;
      const randomAlbumIndex = Math.floor(Math.random() * albumKeys.length);
      const albumKey = albumKeys[randomAlbumIndex];
      const tracks = albumData[albumKey];
      if (!tracks || tracks.length === 0) return;
      const randomTrackIndex = Math.floor(Math.random() * tracks.length);
      currentAlbumIndex = randomAlbumIndex;
      currentTrackIndex = randomTrackIndex;
      updateTrackInfo();
    }

    function unlockAutoplay() {
      const audioElement = document.getElementById("audio-player");
      audioElement.play().catch(() => {});
      document.body.removeEventListener("click", unlockAutoplay);
      document.body.removeEventListener("touchend", unlockAutoplay);
      document.body.removeEventListener("keydown", unlockAutoplay);
    }

    let lastTime = 0;
    let lastUpdate = Date.now();
    let zeroStart = null;
    let justLoaded = false;

    window.onload = function () {
      fetchAlbumData();

      // 검색 디바운스
      let searchTimeout;
      document.getElementById('search-bar').addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
          searchTracks(e.target.value.trim());
        }, 200);
      });

      // 클릭 이벤트 위임 (Clusterize가 콘텐츠를 갈아끼워도 동작)
      document.getElementById('contentArea').addEventListener('click', (e) => {
        const el = e.target.closest('.sidebar-track');
        if (!el) return;
        const path = el.getAttribute('data-path');
        if (path) playTrackByPath(path);
      });

      document.body.addEventListener("click", unlockAutoplay, { once: true });
      document.body.addEventListener("touchend", unlockAutoplay, { once: true });
      document.body.addEventListener("keydown", unlockAutoplay, { once: true });

      const audioElement = document.getElementById("audio-player");

      audioElement.addEventListener("ended", () => { nextTrack(); });
      audioElement.addEventListener("stalled", () => { nextTrack(); });
      audioElement.addEventListener("error", () => { nextTrack(); });

      audioElement.addEventListener("timeupdate", () => {
        if (justLoaded) return;
        const durServer = audioElement.dataset.duration ? parseFloat(audioElement.dataset.duration) : 0;
        const durClient = audioElement.duration || 0;
        const candidates = [durServer, durClient].filter(v => v && !isNaN(v));
        const dur = candidates.length ? Math.min(...candidates) + 0.5 : 0;

        if (dur - audioElement.currentTime <= 1.5) { nextTrack(); }
      });
    };
</script>
</head>

<body>
  <div class="title"><h1>Audio Player</h1></div>
  <div class="main">
    <div class="content">
      <div class="player">
        <input type="text" id="search-bar" placeholder="Search for albums or tracks...">
        <h3 id="track-title"></h3>
        <img id="album-cover" src="/public/none" alt="Album Cover" width="300" height="300" />
        <audio id="audio-player" playsinline controls></audio>
        <div class="buttons">
          <button onclick="previousTrack()">Previous Track</button>
          <button onclick="nextTrack()">Next Track</button>
        </div>
      </div>
      <!-- Clusterize 요구 구조 -->
      <div id="scrollArea" class="sidebar clusterize-scroll">
        <div id="contentArea" class="sidebar-content clusterize-content">
          <div class="clusterize-no-data">Loading…</div>
        </div>
      </div>
      <div class="random-play">
        <button onclick="playRandomTrack()">Random Play</button>
      </div>
    </div>
  </div>
</body>
</html>
