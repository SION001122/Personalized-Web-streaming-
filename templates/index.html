<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Audio Player</title>
  <link rel="stylesheet" href="/static/index.css">
  <style>
    .sidebar {
      width: 300px;
      height: 600px; /* 고정 높이 */
      overflow-y: auto;
      border: 1px solid #ccc;
      -webkit-overflow-scrolling: touch;
    }
    .sidebar-content {
      width: 100%;
    }
    .sidebar-track {
      padding: 4px 10px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
      background: #fff;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .sidebar-album {
      font-weight: bold;
      background: #f0f0f0;
      padding: 4px 10px;
    }
    #audio-player {
      margin-top: 10px;
      width: 250px;
      height: 40px;
    }
  </style>
  <script>
    const basename = (p) => p.split(/[/\\]/).pop();
    const stripExt = (name) => name.replace(/\.[^.]+$/, "");

    let albumData = {};
    let searchIndex = [];
    let albumKeys = [];
    let currentAlbumIndex = 0;
    let currentTrackIndex = 0;
    let audioDuration = 0;

    // 무한스크롤 상태
    let flatTrackList = [];
    let loadedAlbumCount = 0;
    const ALBUM_BATCH_SIZE = 10; // 앨범 10개 단위 로드

    async function fetchAlbumData() {
      const response = await fetch('/albums_list');
      albumData = await response.json();
      albumKeys = Object.keys(albumData);
      createSearchIndex(albumData);

      loadMoreAlbums();
      renderSidebar();
      updateTrackInfo();
    }

    function loadMoreAlbums() {
      const nextAlbums = albumKeys.slice(loadedAlbumCount, loadedAlbumCount + ALBUM_BATCH_SIZE);
      nextAlbums.forEach(albumKey => {
        flatTrackList.push({ type: "album", name: albumKey });
        albumData[albumKey].forEach(track => {
          flatTrackList.push({ type: "track", album: albumKey, track });
        });
      });
      loadedAlbumCount += nextAlbums.length;
    }

    function createSearchIndex(data) {
      searchIndex = [];
      Object.keys(data).forEach(albumKey => {
        data[albumKey].forEach(track => {
          searchIndex.push({
            album: albumKey.toLowerCase(),
            track: track.name.toLowerCase(),
            path: track.path
          });
        });
      });
    }

    function searchTracks() {
      const query = document.getElementById('search-bar').value.toLowerCase();
      const filteredTracks = searchIndex.filter(item =>
        item.album.includes(query) || item.track.includes(query)
      );
      const filteredData = {};
      filteredTracks.forEach(item => {
        if (!filteredData[item.album]) filteredData[item.album] = [];
        filteredData[item.album].push({ name: item.track, path: item.path });
      });

      flatTrackList = [];
      Object.keys(filteredData).forEach(albumKey => {
        flatTrackList.push({ type: "album", name: albumKey });
        filteredData[albumKey].forEach(track => {
          flatTrackList.push({ type: "track", album: albumKey, track });
        });
      });

      renderSidebar(true); // 검색 시 전체 새로 그림
    }

    function renderSidebar(reset = false) {
      const sidebar = document.querySelector('.sidebar');
      const content = document.querySelector('.sidebar-content');

      // 항상 먼저 비움 (겹침 방지)
      content.innerHTML = "";

      flatTrackList.forEach(item => {
        const div = document.createElement("div");
        if (item.type === "album") {
          div.className = "sidebar-album";
          div.textContent = item.name;
        } else {
          div.className = "sidebar-track";
          div.textContent = item.track.name;
          div.onclick = () => playTrackByPath(item.track.path);
        }
        content.appendChild(div);
      });

      // 무한 스크롤 감지
      sidebar.onscroll = () => {
        if (sidebar.scrollTop + sidebar.clientHeight >= sidebar.scrollHeight - 10) {
          if (loadedAlbumCount < albumKeys.length) {
            loadMoreAlbums();
            renderSidebar(); // 새로 그려도 기존 DOM은 지우고 새로 생성
          }
        }
      };
    }

    function playTrackByPath(path) {
      const foundTrack = findTrackByPath(path);
      if (foundTrack) {
        const { albumKey, trackIndex } = foundTrack;
        currentAlbumIndex = albumKeys.indexOf(albumKey);
        currentTrackIndex = trackIndex;
        updateTrackInfo();
      }
    }

    function findTrackByPath(path) {
      for (const albumKey of albumKeys) {
        const trackIndex = albumData[albumKey].findIndex((track) => track.path === path);
        if (trackIndex !== -1) {
          return { albumKey, trackIndex };
        }
      }
      return null;
    }

    async function fetchAudioDuration(path) {
      try {
        const filename = basename(path);
        const res = await fetch(`/audio/duration/${encodeURIComponent(filename)}`);
        if (!res.ok) throw new Error('Failed to fetch audio duration');
        const { duration } = await res.json();
        return Math.floor(duration - 2);
      } catch (e) {
        return 10;
      }
    }

    async function updateTrackInfo() {
      const audioElement = document.getElementById('audio-player');
      const titleElement = document.getElementById('track-title');
      const coverElement = document.getElementById('album-cover');

      const currentAlbum = albumKeys[currentAlbumIndex];
      const currentTrack = albumData[currentAlbum][currentTrackIndex];

      const fileWithExt = basename(currentTrack.path);
      const encoded = encodeURIComponent(fileWithExt);
      const displayName = stripExt(fileWithExt);

      titleElement.textContent = displayName;
      audioElement.src = `/audio/${encoded}`;
      coverElement.src = `/cover/${encoded}`;
      coverElement.onerror = () => {
        // 이미 fallback 시도했으면 다시 안 함
        if (!coverElement.dataset.fallback) {
          coverElement.src = '/public/none';
          coverElement.dataset.fallback = "true";
        }
      };

      try {
        audioDuration = await fetchAudioDuration(currentTrack.path);
        audioElement.load();
        audioElement.play().catch(err => {
          console.warn("Autoplay blocked:", err);
        });
      } catch (err) {}
    }

    function nextTrack() {
      const currentAlbum = albumKeys[currentAlbumIndex];
      if (currentTrackIndex + 1 < albumData[currentAlbum].length) {
        currentTrackIndex++;
      } else if (currentAlbumIndex + 1 < albumKeys.length) {
        currentAlbumIndex++;
        currentTrackIndex = 0;
      } else {
        currentAlbumIndex = 0;
        currentTrackIndex = 0;
      }
      updateTrackInfo();
    }

    function previousTrack() {
      if (currentTrackIndex > 0) {
        currentTrackIndex--;
      } else if (currentAlbumIndex > 0) {
        currentAlbumIndex--;
        const prevAlbum = albumKeys[currentAlbumIndex];
        currentTrackIndex = albumData[prevAlbum].length - 1;
      } else {
        currentAlbumIndex = albumKeys.length - 1;
        const lastAlbum = albumKeys[currentAlbumIndex];
        currentTrackIndex = albumData[lastAlbum].length - 1;
      }
      updateTrackInfo();
    }

    function playRandomTrack() {
      if (albumKeys.length === 0) return;
      const randomAlbumIndex = Math.floor(Math.random() * albumKeys.length);
      const randomTrackIndex = Math.floor(Math.random() * albumData[albumKeys[randomAlbumIndex]].length);
      currentAlbumIndex = randomAlbumIndex;
      currentTrackIndex = randomTrackIndex;
      updateTrackInfo();
    }

    // 최초 사용자 입력으로 autoplay unlock
    function unlockAutoplay() {
      const audioElement = document.getElementById("audio-player");
      audioElement.play().catch(() => {});
      document.body.removeEventListener("click", unlockAutoplay);
      document.body.removeEventListener("touchend", unlockAutoplay);
      document.body.removeEventListener("keydown", unlockAutoplay);
    }

  window.onload = function () {
    fetchAlbumData();
    document.getElementById('search-bar').addEventListener('input', searchTracks);

    // 모든 기기에서 입력 이벤트로 autoplay 해제
    document.body.addEventListener("click", unlockAutoplay, { once: true });
    document.body.addEventListener("touchend", unlockAutoplay, { once: true });
    document.body.addEventListener("keydown", unlockAutoplay, { once: true });

    const audioElement = document.getElementById("audio-player");

    // 트랙이 끝나면 자동 다음 곡 재생
    audioElement.addEventListener("ended", () => {
      nextTrack();
    });

    // currentTime이 3초 동안 멈추면 자동 다음 곡 재생
    let lastTime = 0;
    let stagnantSeconds = 0;
    audioElement.addEventListener("timeupdate", () => {
      if (audioElement.currentTime === lastTime) {
        stagnantSeconds++;
        if (stagnantSeconds >= 3) {
          console.warn("3초간 무음/정지 → 다음 곡으로 이동");
          stagnantSeconds = 0;
          nextTrack();
        }
      } else {
        stagnantSeconds = 0;
        lastTime = audioElement.currentTime;
      }
    });

    // 14초 간격으로 서버 핑
    setInterval(() => {
      fetch("/ping", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({})
      }).catch(() => {});
    }, 14000);
  };
    </script>
    
</head>

<body>
  <div class="title"><h1>Audio Player</h1></div>
  <div class="main">
    <div class="content">
      <div class="player">
        <input type="text" id="search-bar" placeholder="Search for albums or tracks...">
        <h3 id="track-title"></h3>
        <img id="album-cover" src="/public/none" alt="Album Cover" width="300" height="300" />
        <video id="audio-player" playsinline controls></video>
        <div class="buttons">
          <button onclick="previousTrack()">Previous Track</button>
          <button onclick="nextTrack()">Next Track</button>
        </div>
      </div>
      <div class="sidebar">
        <div class="sidebar-content"></div>
      </div>
      <div class="random-play">
        <button onclick="playRandomTrack()">Random Play</button>
      </div>
    </div>
  </div>
</body>
</html>
