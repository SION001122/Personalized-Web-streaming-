<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Audio Player</title>
  <link rel="stylesheet" href="/static/index.css">
  <style>
    .sidebar {
      width: 300px;
      height: 600px;
      overflow-y: auto;
      border: 1px solid #ccc;
      -webkit-overflow-scrolling: touch;
    }
    .sidebar-content {
      width: 100%;
    }
    .sidebar-track {
    padding: 4px 10px;
    border-bottom: 1px solid #eee;
    cursor: pointer;
    background: #fff;

    white-space: normal;
    overflow-wrap: break-word;
    text-overflow: clip;
    }

    .sidebar-album {
    font-weight: bold;
    background: #f0f0f0;
    padding: 4px 10px;

    white-space: normal;
    overflow-wrap: break-word;
    text-overflow: clip;
    }
    #audio-player {
      margin-top: 10px;
      width: 250px;
      height: 40px;
    }
  </style>

  <!-- ✅ MiniSearch CDN -->
  <script src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js"></script>

<script>
    const basename = (p) => p.split(/[/\\]/).pop();
    const stripExt = (name) => name.replace(/\.[^.]+$/, "");
  
    let albumData = {};
    let albumKeys = [];
    let currentAlbumIndex = 0;
    let currentTrackIndex = 0;
  
    let flatTrackList = [];
    let loadedAlbumCount = 0;
    const ALBUM_BATCH_SIZE = 10;

    let miniSearch; // ✅ MiniSearch 인스턴스
  
    async function fetchAlbumData() {
      const response = await fetch('/albums_list');
      albumData = await response.json();
      albumKeys = Object.keys(albumData);
      createSearchIndex(albumData);
  
      loadMoreAlbums();
      renderSidebar();
      updateTrackInfo();
    }
  
    function loadMoreAlbums() {
      const nextAlbums = albumKeys.slice(loadedAlbumCount, loadedAlbumCount + ALBUM_BATCH_SIZE);
      nextAlbums.forEach(albumKey => {
        flatTrackList.push({ type: "album", name: albumKey });
        albumData[albumKey].forEach(track => {
          flatTrackList.push({ type: "track", album: albumKey, track });
        });
      });
      loadedAlbumCount += nextAlbums.length;
    }
  
    function createSearchIndex(data) {
      let docs = [];
      Object.keys(data).forEach(albumKey => {
        data[albumKey].forEach(track => {
          docs.push({
            id: `${albumKey}_${track.path}`,
            album: albumKey,
            track: track.name,
            path: track.path
          });
        });
      });

      // ✅ MiniSearch 인스턴스 생성
      miniSearch = new MiniSearch({
        fields: ['album', 'track'],   // 검색할 필드
        storeFields: ['album', 'track', 'path'], // 결과에 포함할 필드
      });

      miniSearch.addAll(docs);
    }
  
    function searchTracks(query) {
      if (!miniSearch) return;

      if (!query) {
        // 검색어 없으면 전체 다시 로드
        flatTrackList = [];
        albumKeys.forEach(albumKey => {
          flatTrackList.push({ type: "album", name: albumKey });
          albumData[albumKey].forEach(track => {
            flatTrackList.push({ type: "track", album: albumKey, track });
          });
        });
        renderSidebar(true);
        return;
      }

      // ✅ 오타 허용 + 접두사 검색
      const results = miniSearch.search(query, { fuzzy: 0.2, prefix: true });

      const filteredData = {};
      results.forEach(item => {
        if (!filteredData[item.album]) filteredData[item.album] = [];
        filteredData[item.album].push({ name: item.track, path: item.path });
      });

      flatTrackList = [];
      Object.keys(filteredData).forEach(albumKey => {
        flatTrackList.push({ type: "album", name: albumKey });
        filteredData[albumKey].forEach(track => {
          flatTrackList.push({ type: "track", album: albumKey, track });
        });
      });

      renderSidebar(true);
    }
  
    function renderSidebar(reset = false) {
      const sidebar = document.querySelector('.sidebar');
      const content = document.querySelector('.sidebar-content');
      content.innerHTML = "";
  
      flatTrackList.forEach(item => {
        const div = document.createElement("div");
        if (item.type === "album") {
          div.className = "sidebar-album";
          div.textContent = item.name;
        } else {
          div.className = "sidebar-track";
          div.textContent = item.track.name;
          div.onclick = () => playTrackByPath(item.track.path);
        }
        content.appendChild(div);
      });
  
      sidebar.onscroll = () => {
        if (sidebar.scrollTop + sidebar.clientHeight >= sidebar.scrollHeight - 10) {
          if (loadedAlbumCount < albumKeys.length) {
            loadMoreAlbums();
            renderSidebar();
          }
        }
      };
    }
  
    function playTrackByPath(path) {
      const foundTrack = findTrackByPath(path);
      if (foundTrack) {
        const { albumKey, trackIndex } = foundTrack;
        currentAlbumIndex = albumKeys.indexOf(albumKey);
        currentTrackIndex = trackIndex;
        updateTrackInfo();
      }
    }
  
    function findTrackByPath(path) {
      for (const albumKey of albumKeys) {
        const trackIndex = albumData[albumKey].findIndex((track) => track.path === path);
        if (trackIndex !== -1) {
          return { albumKey, trackIndex };
        }
      }
      return null;
    }
  
    async function updateTrackInfo() {
      const audioElement = document.getElementById('audio-player');
      const titleElement = document.getElementById('track-title');
      const coverElement = document.getElementById('album-cover');
  
      const currentAlbum = albumKeys[currentAlbumIndex];
      const currentTrack = albumData[currentAlbum][currentTrackIndex];
  
      const fileWithExt = basename(currentTrack.path);
      const encoded = encodeURIComponent(fileWithExt);
      const displayName = stripExt(fileWithExt);
  
      titleElement.textContent = displayName;
      audioElement.src = `/audio/${encoded}`;
      coverElement.src = `/cover/${encoded}`;
      coverElement.onerror = () => {
        if (!coverElement.dataset.fallback) {
          coverElement.src = '/public/none';
          coverElement.dataset.fallback = "true";
        }
      };
  
      try {
        audioElement.load();
        justLoaded = true;
        setTimeout(() => { justLoaded = false; }, 2000);
  
        fetch(`/audio/duration/${encoded}`)
          .then(res => res.json())
          .then(data => {
            if (data.duration) {
              audioElement.dataset.duration = data.duration;
              console.log(`서버 제공 duration: ${data.duration.toFixed(2)}초`);
            }
          })
          .catch(() => {});
  
        audioElement.play().catch(() => {});
      } catch (err) {}
    }
  
    function nextTrack() {
      const currentAlbum = albumKeys[currentAlbumIndex];
      if (currentTrackIndex + 1 < albumData[currentAlbum].length) {
        currentTrackIndex++;
      } else if (currentAlbumIndex + 1 < albumKeys.length) {
        currentAlbumIndex++;
        currentTrackIndex = 0;
      } else {
        currentAlbumIndex = 0;
        currentTrackIndex = 0;
      }
      updateTrackInfo();
    }
  
    function previousTrack() {
      if (currentTrackIndex > 0) {
        currentTrackIndex--;
      } else if (currentAlbumIndex > 0) {
        currentAlbumIndex--;
        const prevAlbum = albumKeys[currentAlbumIndex];
        currentTrackIndex = albumData[prevAlbum].length - 1;
      } else {
        currentAlbumIndex = albumKeys.length - 1;
        const lastAlbum = albumKeys[currentAlbumIndex];
        currentTrackIndex = albumData[lastAlbum].length - 1;
      }
      updateTrackInfo();
    }
  
    function playRandomTrack() {
      if (albumKeys.length === 0) return;
      const randomAlbumIndex = Math.floor(Math.random() * albumKeys.length);
      const albumKey = albumKeys[randomAlbumIndex];
      const tracks = albumData[albumKey];
      if (!tracks || tracks.length === 0) return;
      const randomTrackIndex = Math.floor(Math.random() * tracks.length);
      currentAlbumIndex = randomAlbumIndex;
      currentTrackIndex = randomTrackIndex;
      updateTrackInfo();
    }
  
    function unlockAutoplay() {
      const audioElement = document.getElementById("audio-player");
      audioElement.play().catch(() => {});
      document.body.removeEventListener("click", unlockAutoplay);
      document.body.removeEventListener("touchend", unlockAutoplay);
      document.body.removeEventListener("keydown", unlockAutoplay);
    }
  
    let lastTime = 0;
    let lastUpdate = Date.now();
    let zeroStart = null;
    let justLoaded = false;
  
    window.onload = function () {
      fetchAlbumData();

      // ✅ debounce 추가
      let searchTimeout;
      document.getElementById('search-bar').addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
          searchTracks(e.target.value.trim());
        }, 200);
      });
  
      document.body.addEventListener("click", unlockAutoplay, { once: true });
      document.body.addEventListener("touchend", unlockAutoplay, { once: true });
      document.body.addEventListener("keydown", unlockAutoplay, { once: true });
  
      const audioElement = document.getElementById("audio-player");
  
      audioElement.addEventListener("ended", () => {
        console.log("곡 종료 이벤트 → 다음 곡");
        nextTrack();
      });
  
      audioElement.addEventListener("stalled", () => {
        console.warn("스트리밍 stalled → 다음 곡");
        nextTrack();
      });
  
      audioElement.addEventListener("error", () => {
        console.error("오디오 재생 오류 → 다음 곡");
        nextTrack();
      });
  
      audioElement.addEventListener("timeupdate", () => {
        if (justLoaded) return;
  
        const durServer = audioElement.dataset.duration
          ? parseFloat(audioElement.dataset.duration)
          : 0;
        const durClient = audioElement.duration || 0;
        
        const candidates = [durServer, durClient].filter(v => v && !isNaN(v));
        const dur = candidates.length ? Math.min(...candidates) + 0.5 : 0;
  
        if (!dur || isNaN(dur) || dur === 0) {
          if (audioElement.currentTime <= 0.01) {
            if (!zeroStart) zeroStart = Date.now();
            else if (Date.now() - zeroStart >= 1500) {
              console.warn("00/00 상태에서 1.5초 정체 → 다음 곡");
              zeroStart = null;
              nextTrack();
            }
          }
          return;
        }
  
        if (audioElement.currentTime <= 0.01) {
          if (!zeroStart) zeroStart = Date.now();
          else if (Date.now() - zeroStart >= 1500) {
            console.warn("0초에서 1.5초 정체 → 다음 곡");
            zeroStart = null;
            nextTrack();
          }
        } else {
          zeroStart = null;
        }
  
        if (!audioElement.paused) {
          if (audioElement.currentTime === lastTime) {
            if (Date.now() - lastUpdate >= 1500) {
              console.warn("재생바 1.5초 이상 정체 → 다음 곡");
              lastUpdate = Date.now();
              nextTrack();
            }
          } else {
            lastTime = audioElement.currentTime;
            lastUpdate = Date.now();
          }
        }
  
        if (dur - audioElement.currentTime <= 1.5) {
          console.log("끝나기 직전 → 다음 곡");
          nextTrack();
        }
      });
  
      setInterval(() => {
        if (justLoaded) return;
        const audioElement = document.getElementById("audio-player");
        if (!audioElement) return;
  
        if ((isNaN(audioElement.duration) || audioElement.duration === 0) &&
            audioElement.currentTime <= 0.01 &&
            !audioElement.paused) {
          if (!zeroStart) zeroStart = Date.now();
          else if (Date.now() - zeroStart >= 1500) {
            console.warn("강제 검사: 0초에서 1.5초 정체 → 다음 곡");
            zeroStart = null;
            nextTrack();
          }
        }
      }, 1000);
    };
</script>
</head>

<body>
  <div class="title"><h1>Audio Player</h1></div>
  <div class="main">
    <div class="content">
      <div class="player">
        <input type="text" id="search-bar" placeholder="Search for albums or tracks...">
        <h3 id="track-title"></h3>
        <img id="album-cover" src="/public/none" alt="Album Cover" width="300" height="300" />
        <audio id="audio-player" playsinline controls></audio>
        <div class="buttons">
          <button onclick="previousTrack()">Previous Track</button>
          <button onclick="nextTrack()">Next Track</button>
        </div>
      </div>
      <div class="sidebar">
        <div class="sidebar-content"></div>
      </div>
      <div class="random-play">
        <button onclick="playRandomTrack()">Random Play</button>
      </div>
    </div>
  </div>
</body>
</html>
